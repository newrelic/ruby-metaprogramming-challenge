#!/usr/bin/env ruby
# Test solutions to New Relic's metaprogramming counter challenge.
#
# ./tmp/program.rb is auto generated by the test cases.
require 'test/unit'
require 'fileutils'

SOLUTION_FILE = ARGV[0]
unless SOLUTION_FILE
  warn "usage #$0 <SOLUTION_FILE>"
  exit 1
end
class MetaCounterTest < Test::Unit::TestCase

  def workspace
    File.expand_path(File.dirname(__FILE__) + '/tmp')
  end

  def program_path
    workspace + '/program.rb'
  end

  def solution_path
    SOLUTION_FILE
  end

  def create_program(source)
    FileUtils.mkdir_p(workspace)
    File.open(program_path, 'w') do |f|
      f.print source
    end
  end

  def assert_sig_and_count(output, method_signature, count)
    # assert there's a line of output like "String#to_s called 10 times"
    regexp = /#{Regexp.escape(method_signature)} .*\b#{Regexp.escape(count.to_s)}\b/
    assert output.match(regexp),
      "Expected output to include '#{method_signature} called #{count} times'\nGot:\n#{output}"
  end


  def execute_program(count_calls_to, source)
    create_program(source)
    `COUNT_CALLS_TO='#{count_calls_to}' ruby -r #{solution_path} #{program_path} 2>&1`
  end

  def test_standard_lib_class_and_method
    output = execute_program('String#to_s', <<-RB)
    10.times{ "foo".to_s }
    RB
    assert_sig_and_count(output, 'String#to_s', 10)
  end

  def test_method_defined_in_class
    output = execute_program('A#b', <<-RB)
    class A; def b; end; end
    10.times{ A.new.b }
    RB
    assert_sig_and_count(output, 'A#b', 10)
  end

  def test_nested_constant_lookup
    output = execute_program('A::B::C::D::E#b', <<-RB)
    class A; class B; class C; class D; class E; def b; end; end; end; end; end; end
    10.times{ A::B::C::D::E.new.b }
    RB
    assert_sig_and_count(output, 'A::B::C::D::E#b', 10)
  end

  def test_method_inherited_by_class
    output = execute_program('B#b', <<-RB)
    class A; def b; end; end
    class B < A; end
    10.times{ B.new.b }
    RB
    assert_sig_and_count(output, 'B#b', 10)
  end

  def test_method_inherited_by_class_and_counted_on_ancestor
    output = execute_program('A#b', <<-RB)
    class A; def b; end; end
    class B < A; end
    10.times{ B.new.b }
    RB
    assert_sig_and_count(output, 'A#b', 10)
  end

  def test_method_inherited_by_class_then_overridden_and_counted_on_ancestor
    output = execute_program('A#b', <<-RB)
    class A; def b; end; end
    class B < A; end
    10.times{ B.new.b }
    class B; def b; end; end
    10.times{ B.new.b }
    RB
    assert_sig_and_count(output, 'A#b', 10)
  end

  def test_method_inherited_by_class_then_overridden
    output = execute_program('B#b', <<-RB)
    class A; def b; end; end
    class B < A; end
    10.times{ B.new.b }
    class B; def b; end; end
    10.times{ B.new.b }
    RB
    assert_sig_and_count(output, 'B#b', 20)
  end

  def test_method_included_via_module
    output = execute_program('B#b', <<-RB)
    module A; def b; end; end
    class B; include A; end
    10.times{ B.new.b }
    RB
    assert_sig_and_count(output, 'B#b', 10)
  end

  def test_method_included_via_module_and_counted_through_module
    output = execute_program('A#b', <<-RB)
    module A; def b; end; end
    class B; include A; end
    10.times{ B.new.b }
    RB
    assert_sig_and_count(output, 'A#b', 10)
  end

  def test_method_extended_into_object
    output = execute_program('B#b', <<-RB)
    module A; def b; end; end
    class B; include A; end
    b = B.new
    b.extend A
    10.times{ b.b }
    RB
    assert_sig_and_count(output, 'B#b', 10)
  end

  def test_method_extended_into_object_and_counted_through_module
    output = execute_program('A#b', <<-RB)
    module A; def b; end; end
    class B; include A; end
    b = B.new
    b.extend A
    10.times{ b.b }
    RB
    assert_sig_and_count(output, 'A#b', 10)
  end

  # This one is tricky because it's a weird symbol (which makes
  # alias_method_chaining hard) and it's often used in the instrumentation
  # itself to increment a counter (leading to stack overflow).
  def test_integer_addition
    output = execute_program('Fixnum#+', <<-RB)
    10.times{ |i| i + i}
    RB
    assert_sig_and_count(output, 'Fixnum#+', 10)
  end

  def test_subtraction
    output = execute_program('Fixnum#-', <<-RB)
    10.times{ |i| i - i}
    RB
    assert_sig_and_count(output, 'Fixnum#-', 10)
  end

  def test_division
    output = execute_program('Fixnum#/', <<-RB)
    10.times{ |i| i / 2}
    RB
    assert_sig_and_count(output, 'Fixnum#/', 10)
  end

  def test_multiplication
    output = execute_program('Fixnum#*', <<-RB)
    10.times{ |i| i * 2}
    RB
    assert_sig_and_count(output, 'Fixnum#*', 10)
  end

  def test_question_method
    output = execute_program('Fixnum#odd?', <<-RB)
    10.times{ |i| i.odd? }
    RB
    assert_sig_and_count(output, 'Fixnum#odd?', 10)
  end

  def test_bang_method
    output = execute_program('String#sub!', <<-RB)
    10.times{ |i| i.to_s.sub! '1', '2'}
    RB
    assert_sig_and_count(output, 'String#sub!', 10)
  end

  def test_bracket_method
    output = execute_program('Fixnum#[]', <<-RB)
    10.times{ |i| i[0]}
    RB
    assert_sig_and_count(output, 'Fixnum#[]', 10)
  end

  def test_class_method
    output = execute_program('A.b', <<-RB)
    class A; def self.b; end; end
    10.times{ A.b}
    RB
    assert_sig_and_count(output, 'A.b', 10)
  end

  def test_class_method_inherited
    output = execute_program('B.b', <<-RB)
    class A; def self.b; end; end
    class B < A; end
    10.times{ B.b}
    RB
    assert_sig_and_count(output, 'B.b', 10)
  end

  def test_class_method_extended
    output = execute_program('B.b', <<-RB)
    module A; def b; end; end
    class B; extend A end
    10.times{ B.b}
    RB
    assert_sig_and_count(output, 'B.b', 10)
  end

  def test_module_extends_self_then_defines_method
    output = execute_program('A.b', <<-RB)
    module A; extend self; def b; end; end
    10.times{ A.b}
    RB
    assert_sig_and_count(output, 'A.b', 10)
  end

  def test_module_extends_self_then_defines_method_counted_at_instance_level
    output = execute_program('A#b', <<-RB)
    module A; extend self; def b; end; end
    10.times{ A.b}
    RB
    assert_sig_and_count(output, 'A#b', 10)
  end


  def test_module_defines_method_then_extends_self
    output = execute_program('A.b', <<-RB)
    module A; def b; end; extend self; end
    10.times{ A.b}
    RB
    assert_sig_and_count(output, 'A.b', 10)
  end

  def test_module_method
    output = execute_program('A.b', <<-RB)
    module A; def self.b; end; end
    10.times{ A.b}
    RB
    assert_sig_and_count(output, 'A.b', 10)
  end

  def test_works_with_single_argument_methods
    output = execute_program('A#b', <<-RB)
    class A; def b(a); puts "I got " + a.inspect ; end; end
    A.new.b 'a sandwich!'
    RB
    assert output.include?('I got "a sandwich!"'), "Got:\n #{output}"
  end

  def test_works_with_multiple_argument_methods
    output = execute_program('A#b', <<-RB)
    class A; def b(a, b, c); puts "I got " + [a, b, c].join(' ') ; end; end
    A.new.b 'a', 'ham', 'sandwich!'
    RB
    assert output.include?('I got a ham sandwich!'), "Got:\n #{output}"
  end

  def test_works_with_var_argument_methods
    output = execute_program('A#b', <<-RB)
    class A; def b(*a); puts "I got " + a.join(' ') ; end; end
    A.new.b 'a', 'ham', 'sandwich!'
    RB
    assert output.include?('I got a ham sandwich!'), "Got:\n #{output}"
  end

  def test_works_with_block_argument_methods
    output = execute_program('A#b', <<-RB)
    class A; def b(*a); yield a ; end; end
    A.new.b('a', 'ham', 'sandwich!'){|*a| puts "I got " + a.join(' ')}
    RB
    assert output.include?('I got a ham sandwich!'), "Got:\n #{output}"
  end
end
